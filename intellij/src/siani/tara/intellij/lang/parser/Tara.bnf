{
	parserClass='siani.tara.intellij.lang.parser.TaraParser'
	parserUtilClass="siani.tara.intellij.lang.parser.TaraParserUtil"
	psiVisitorName="TaraVisitor"
	extends='com.intellij.extapi.psi.ASTWrapperPsiElement'
	implements='siani.tara.intellij.lang.psi.TaraPsiElement'
	psiClassPrefix='Tara'
	psiImplClassSuffix='Impl'
	psiPackage='siani.tara.intellij.lang.psi'
	psiImplPackage='siani.tara.intellij.lang.psi.impl'

	elementTypeHolderClass='siani.tara.intellij.lang.psi.TaraTypes'
	elementTypeClass='siani.tara.intellij.lang.psi.TaraElementType'
	tokenTypeClass='siani.tara.intellij.lang.psi.TaraTokenType'

	psiImplUtilClass='siani.tara.intellij.lang.psi.impl.TaraPsiImplUtil'
}

root ::= NEWLINE* dslDeclaration? imports? (concept NEWLINE+)*

dslDeclaration ::= DSL headerReference NEWLINE+

imports ::= (anImport NEWLINE*)+

anImport ::= USE headerReference NEWLINE {
	mixin= 'siani.tara.intellij.lang.psi.impl.ImportMixin'
    implements='siani.tara.intellij.lang.psi.Import'
}

doc::= DOC_LINE+ {
	mixin= 'siani.tara.intellij.lang.psi.impl.DocMixin'
	implements='siani.tara.intellij.lang.psi.Doc'
}

concept ::= signature annotations? body? {
	pin = 2
	mixin= 'siani.tara.intellij.lang.psi.impl.ConceptMixin'
	implements='siani.tara.intellij.lang.psi.Concept'
}
//simplify
signature::= (subConcept | metaIdentifier parameters? identifier? parent?) address? {
	pin = 1
	mixin= 'siani.tara.intellij.lang.psi.impl.SignatureMixin'
	implements='siani.tara.intellij.lang.psi.Signature'
}

address::= ADDRESS_VALUE
{pin = 1}

private subConcept ::= SUB parameters? identifier
{pin = 1}

private parent ::= EXTENDS identifierReference
{pin = 1}

parameters ::= LEFT_PARENTHESIS (explicitParameters | implicitParameters)? RIGHT_PARENTHESIS {
	pin = 1
	mixin = 'siani.tara.intellij.lang.psi.impl.ParametersMixin'
	implements = 'siani.tara.intellij.lang.psi.Parameters'
}

private explicitParameters ::= explicitParameter (COMMA explicitParameter)*
{ pin = 2}

private implicitParameters ::= implicitParameter (COMMA implicitParameter)*
{ pin = 1}

explicitParameter ::= identifier EQUALS parameterValue {
    pin = 2
	mixin = 'siani.tara.intellij.lang.psi.impl.ParameterMixin'
	implements = 'siani.tara.intellij.lang.psi.Parameter'
}

implicitParameter ::= parameterValue {
    mixin = 'siani.tara.intellij.lang.psi.impl.ParameterMixin'
    implements = 'siani.tara.intellij.lang.psi.Parameter'
}

parameterValue ::= identifierReference+
				| stringValue+
		        | booleanValue+
		        | naturalValue+ measureValue?
		        | integerValue+ measureValue?
		        | doubleValue+  measureValue?
		        | dateValue+
		        | metaWord
		        | emptyField

metaWord ::= metaIdentifier metaWordNames*
{pin = 1}
private metaWordNames ::= DOT identifier
{pin = 1}

body ::= (NEW_LINE_INDENT | INLINE) (conceptConstituents NEWLINE+)+ DEDENT {
	pin = 1
	mixin = 'siani.tara.intellij.lang.psi.impl.BodyMixin'
	implements = 'siani.tara.intellij.lang.psi.Body'
}

private conceptConstituents ::= varInit | variable | concept | facetTarget | facetApply | conceptReference | doc

conceptReference ::= HAS identifierReference annotations?
{
	pin = 2
	mixin = 'siani.tara.intellij.lang.psi.impl.ConceptReferenceMixin'
	implements = 'siani.tara.intellij.lang.psi.ConceptReference'
}

variable ::= VAR variableType annotations? {
	pin = 2
	mixin = 'siani.tara.intellij.lang.psi.impl.VariableMixin'
	implements = 'siani.tara.intellij.lang.psi.Variable'
}
variableType::= naturalAttribute | integerAttribute | ratioAttribute | measureAttribute | doubleAttribute | booleanAttribute | stringAttribute |
		dateAttribute | resource | referenceAttribute | word

naturalAttribute     ::= NATURAL_TYPE doubleMeasure? LIST? IDENTIFIER_KEY (EQUALS naturalValue+ measureValue?)?      {pin=1}
integerAttribute     ::= INT_TYPE     doubleMeasure? LIST? IDENTIFIER_KEY (EQUALS integerValue+ measureValue?)?      {pin=1}
resource             ::= RESOURCE_KEY attributeType IDENTIFIER_KEY (EQUALS stringValue)? {pin=1}
booleanAttribute     ::= BOOLEAN_TYPE LIST? IDENTIFIER_KEY (EQUALS booleanValue+)?       {pin=1}
stringAttribute      ::= STRING_TYPE  LIST? IDENTIFIER_KEY (EQUALS stringValue+)?       {pin=1}
dateAttribute        ::= DATE_TYPE    LIST? IDENTIFIER_KEY (EQUALS stringValue+)?        {pin=1}
ratioAttribute       ::= RATIO_TYPE   LIST? IDENTIFIER_KEY (EQUALS doubleValue+)?        {pin=1}

doubleAttribute      ::= DOUBLE_TYPE  (LIST | count)? doubleMeasure? IDENTIFIER_KEY (EQUALS doubleValue+ measureValue?)?    {pin=1}
measureAttribute     ::= MEASURE_TYPE_KEY attributeType (LIST | count)? IDENTIFIER_KEY (EQUALS doubleValue+  measureValue?)?   {pin=1}
referenceAttribute   ::= identifierReference LIST? IDENTIFIER_KEY (EQUALS emptyField)? {
	pin = 1
	mixin = 'siani.tara.intellij.lang.psi.impl.ReferenceStatementMixin'
	implements = 'siani.tara.intellij.lang.psi.ReferenceStatement'
}

word ::= WORD_KEY LIST? IDENTIFIER_KEY NEW_LINE_INDENT (IDENTIFIER_KEY STAR? NEWLINE)+ DEDENT {
	pin = 1
	mixin = 'siani.tara.intellij.lang.psi.impl.WordMixin'
	implements = 'siani.tara.intellij.lang.psi.Word'
}

attributeType   ::= COLON measureType
doubleMeasure   ::= COLON (MEASURE_VALUE_KEY | IDENTIFIER_KEY)
measureType     ::= IDENTIFIER_KEY {
	implements = 'siani.tara.intellij.lang.psi.MeasureType'
}

stringValue     ::= STRING_VALUE_KEY  | (NEWLINE? STRING_MULTILINE_VALUE_KEY)
booleanValue    ::= BOOLEAN_VALUE_KEY
naturalValue    ::= NATURAL_VALUE_KEY
integerValue    ::= NATURAL_VALUE_KEY | NEGATIVE_VALUE_KEY
doubleValue     ::= NATURAL_VALUE_KEY | NEGATIVE_VALUE_KEY | DOUBLE_VALUE_KEY
dateValue       ::= DATE_VALUE_KEY
linkValue       ::= ADDRESS_VALUE | identifierReference
measureValue    ::= IDENTIFIER_KEY | MEASURE_VALUE_KEY

count           ::= LEFT_SQUARE NATURAL_VALUE_KEY RIGHT_SQUARE

facetApply ::= AS metaIdentifier parameters? (WITH metaIdentifier)? body? {
	pin = 1
	mixin = 'siani.tara.intellij.lang.psi.impl.FacetApplyMixin'
    implements = 'siani.tara.intellij.lang.psi.FacetApply'
}

facetTarget ::= ON identifierReference ALWAYS? body?
{pin = 1}

annotations ::= IS annotation+ {
	pin = 1
	mixin = 'siani.tara.intellij.lang.psi.impl.AnnotationsMixin'
	implements = 'siani.tara.intellij.lang.psi.Annotations'
}

annotation ::= PLUS? (ABSTRACT | TERMINAL | SINGLE | REQUIRED | NAMED
	| COMPONENT | ROOT | FACET | INTENTION | PROPERTY | LOCAL | ADDRESSED | AGGREGATED | READONLY | CASE) {
	pin = 2
	mixin = 'siani.tara.intellij.lang.psi.impl.AnnotationMixin'
	implements = 'siani.tara.intellij.lang.psi.Annotation'
}

varInit ::= IDENTIFIER_KEY EQUALS varInitValue {
    pin = 2
	mixin = 'siani.tara.intellij.lang.psi.impl.VarInitMixin'
	implements = 'siani.tara.intellij.lang.psi.VarInit'
}

varInitValue ::= emptyField
                | identifierReference+
                | linkValue+
                | stringValue+
                | booleanValue+
                | naturalValue+ measureValue?
                | integerValue+ measureValue?
                | doubleValue+  measureValue?

emptyField ::= EMPTY_REF

headerReference ::= hierarchy* identifier {
	pin = 2
	mixin = 'siani.tara.intellij.lang.psi.impl.IdentifierReferenceMixin'
	implements = 'siani.tara.intellij.lang.psi.HeaderReference'
}

identifierReference ::= hierarchy* identifier {
	pin = 2
	mixin = 'siani.tara.intellij.lang.psi.impl.IdentifierReferenceMixin'
	implements = 'siani.tara.intellij.lang.psi.IdentifierReference'
}

private hierarchy ::= identifier DOT
{pin = 2}

identifier ::=  IDENTIFIER_KEY {
	mixin = 'siani.tara.intellij.lang.psi.impl.IdentifierMixin'
	implements = 'siani.tara.intellij.lang.psi.Identifier'
}

metaIdentifier ::= METAIDENTIFIER_KEY | IDENTIFIER_KEY {
	mixin = 'siani.tara.intellij.lang.psi.impl.MetaIdentifierMixin'
	implements = 'siani.tara.intellij.lang.psi.MetaIdentifier'
}