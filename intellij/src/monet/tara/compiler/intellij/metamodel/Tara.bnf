{
  parserClass='monet.tara.compiler.intellij.parser.TaraParser'
  parserUtilClass="monet.tara.compiler.intellij.parser.TaraParserUtil"

  extends='com.intellij.extapi.psi.ASTWrapperPsiElement'

  psiClassPrefix='Tara'
  psiImplClassSuffix='Impl'
  psiPackage='monet.tara.compiler.intellij.psi'
  psiImplPackage='monet.tara.compiler.intellij.psi.impl'

  elementTypeHolderClass='monet.tara.compiler.intellij.psi.TaraTypes'
  elementTypeClass='monet.tara.compiler.intellij.psi.TaraElementType'
  tokenTypeClass='monet.tara.compiler.intellij.psi.TaraTokenType'

  psiImplUtilClass='monet.tara.compiler.intellij.psi.impl.TaraPsiImplUtil'
}

root ::= (concept | NEWLINE)*

concept ::=  doc? conceptSignature conceptAnnotations? conceptBody?
{ mixin= 'monet.tara.compiler.intellij.psi.impl.TaraConceptMixin'
implements='monet.tara.compiler.intellij.psi.IConcept'
methods=[getIdentifier]
}

conceptSignature ::=  (CONCEPT_KEY | extendedConcept) modifier? AS identifier
conceptBody ::= NEW_LINE_INDENT (conceptConstituents NEWLINE+)+ DEDENT

extendedConcept::= IDENTIFIER_KEY (DOT IDENTIFIER_KEY)*
{mixin= 'monet.tara.compiler.intellij.psi.impl.TaraExtendedConceptMixin' methods=[getIdentifier]}

identifier  ::=  IDENTIFIER_KEY
{mixin= 'monet.tara.compiler.intellij.psi.impl.TaraIdentifierMixin' methods=[getIdentifier]}

component ::= doc? conceptSignature componentAnnotations? conceptBody?
                | extendedConcept componentAnnotations?
{ mixin= 'monet.tara.compiler.intellij.psi.impl.TaraComponentMixin'
implements='monet.tara.compiler.intellij.psi.IConcept'
methods=[getIdentifier]
}

conceptConstituents ::= attribute
                      | referenceStatement
                      | word
                      | from
                      | component

referenceStatement ::= VAR extendedConcept LIST? IDENTIFIER_KEY

attribute::= VAR    UID_TYPE IDENTIFIER_KEY stringAssign?
           | VAR     INT_TYPE (IDENTIFIER_KEY integerAssign? | LIST IDENTIFIER_KEY integerListAssign?)
           | VAR  DOUBLE_TYPE (IDENTIFIER_KEY doubleAssign?  | LIST IDENTIFIER_KEY doubleListAssign?)
           | VAR NATURAL_TYPE (IDENTIFIER_KEY naturalAssign? | LIST IDENTIFIER_KEY naturalListAssign?)
           | VAR BOOLEAN_TYPE (IDENTIFIER_KEY booleanAssign? | LIST IDENTIFIER_KEY booleanListAssign?)
           | VAR  STRING_TYPE (IDENTIFIER_KEY stringAssign?  | LIST IDENTIFIER_KEY stringListAssign?)

word::= VAR WORD_KEY IDENTIFIER_KEY NEW_LINE_INDENT (IDENTIFIER_KEY NEWLINE+)+ DEDENT

stringAssign   ::= ASSIGN STRING_VALUE
booleanAssign  ::= ASSIGN BOOLEAN_VALUE
integerAssign  ::= ASSIGN integerValue
doubleAssign   ::= ASSIGN (integerValue | DOUBLE_VALUE)
naturalAssign  ::= ASSIGN NATURAL_VALUE

stringListAssign   ::= ASSIGN LEFT_SQUARE STRING_VALUE+ RIGHT_SQUARE
booleanListAssign  ::= ASSIGN LEFT_SQUARE BOOLEAN_VALUE+ RIGHT_SQUARE
integerListAssign  ::= ASSIGN LEFT_SQUARE integerValue+ RIGHT_SQUARE
doubleListAssign   ::= ASSIGN LEFT_SQUARE (integerValue | DOUBLE_VALUE)+ RIGHT_SQUARE
naturalListAssign  ::= ASSIGN LEFT_SQUARE NATURAL_VALUE+ RIGHT_SQUARE

from::= FROM_KEY fromAnnotations? fromBody

fromBody::= NEW_LINE_INDENT (fromComponent NEWLINE+)+ DEDENT

fromComponent::= (doc? conceptSignature fromComponentAnnotations? conceptBody?) | (extendedConcept fromComponentAnnotations?)
{ mixin= 'monet.tara.compiler.intellij.psi.impl.TaraFromComponentMixin'
implements='monet.tara.compiler.intellij.psi.IConcept'
methods=[getIdentifier]
}
fromComponentAnnotations ::= OPEN_AN (HAS_CODE | EXTENSIBLE | SINGLETON)+ CLOSE_AN
conceptAnnotations     ::= OPEN_AN (ROOT | HAS_CODE | EXTENSIBLE | SINGLETON)+ CLOSE_AN
componentAnnotations   ::= OPEN_AN (MULTIPLE | OPTIONAL | HAS_CODE | EXTENSIBLE| SINGLETON)+ CLOSE_AN
fromAnnotations        ::= OPEN_AN (OPTIONAL | MULTIPLE)+ CLOSE_AN

integerValue::= NATURAL_VALUE
              | NEGATIVE_VALUE

modifier::= ABSTRACT
          | FINAL

doc::= DOC_LINE
     | DOC_BLOCK
