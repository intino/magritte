{
  parserClass='monet.tara.compiler.intellij.parser.TaraParser'
  parserUtilClass="monet.tara.compiler.intellij.parser.TaraParserUtil"

  extends='com.intellij.extapi.psi.ASTWrapperPsiElement'

  psiClassPrefix='Tara'
  psiImplClassSuffix='Impl'
  psiPackage='monet.tara.compiler.intellij.psi'
  psiImplPackage='monet.tara.compiler.intellij.psi.impl'

  elementTypeHolderClass='monet.tara.compiler.intellij.psi.TaraTypes'
  elementTypeClass='monet.tara.compiler.intellij.psi.TaraElementType'
  tokenTypeClass='monet.tara.compiler.intellij.psi.TaraTokenType'

  psiImplUtilClass='monet.tara.compiler.intellij.psi.impl.TaraPsiImplUtil'
}

root ::= (concept | NEWLINE)*

concept ::=  doc? conceptSignature conceptAnnotations? conceptBody?
{ mixin= 'monet.tara.compiler.intellij.psi.impl.TaraConceptMixin'
implements='monet.tara.compiler.intellij.psi.IConcept'
methods=[getIdentifier getIdentifierNode]
}

conceptSignature ::=  (CONCEPT_KEY | extendedConcept) modifier? AS identifier

extendedConcept::= IDENTIFIER_KEY (DOT IDENTIFIER_KEY)*
{mixin= 'monet.tara.compiler.intellij.psi.impl.TaraExtendedConceptMixin' methods=[getIdentifier]}

component ::= doc? conceptSignature componentAnnotations? conceptBody?
                | extendedConcept componentAnnotations?
{ mixin= 'monet.tara.compiler.intellij.psi.impl.TaraComponentMixin'
implements='monet.tara.compiler.intellij.psi.IConcept'
methods=[getIdentifier]
}
identifier  ::=  IDENTIFIER_KEY {mixin= 'monet.tara.compiler.intellij.psi.impl.TaraIdentifierMixin' methods=[getIdentifier]}

conceptBody ::= NEW_LINE_INDENT (conceptConstituents NEWLINE+)+ DEDENT

conceptConstituents ::= attribute
                      | attributeList
                      | referenceStatement
                      | word
                      | from
                      | component

referenceStatement ::= VAR extendedConcept LIST? IDENTIFIER_KEY

attribute::= VAR     UID_TYPE IDENTIFIER_KEY stringAssign?
           | VAR     INT_TYPE IDENTIFIER_KEY integerAssign?
           | VAR  DOUBLE_TYPE IDENTIFIER_KEY doubleAssign?
           | VAR NATURAL_TYPE IDENTIFIER_KEY naturalAssign?
           | VAR BOOLEAN_TYPE IDENTIFIER_KEY booleanAssign?
           | VAR  STRING_TYPE IDENTIFIER_KEY stringAssign?

word::= VAR WORD_KEY IDENTIFIER_KEY NEW_LINE_INDENT (IDENTIFIER_KEY NEWLINE+)+ DEDENT;

attributeList::= VAR     INT_TYPE LIST IDENTIFIER_KEY integerListAssign?
               | VAR  DOUBLE_TYPE LIST IDENTIFIER_KEY doubleListAssign?
               | VAR NATURAL_TYPE LIST IDENTIFIER_KEY naturalListAssign?
               | VAR BOOLEAN_TYPE LIST IDENTIFIER_KEY booleanListAssign?
               | VAR  STRING_TYPE LIST IDENTIFIER_KEY stringListAssign?

stringAssign   ::= ASSIGN STRING_VALUE
booleanAssign  ::= ASSIGN BOOLEAN_VALUE
integerAssign  ::= ASSIGN integerValue
doubleAssign   ::= ASSIGN (integerValue | DOUBLE_VALUE)
naturalAssign  ::= ASSIGN NATURAL_VALUE

stringListAssign   ::= ASSIGN LEFT_SQUARE STRING_VALUE+ RIGHT_SQUARE
booleanListAssign  ::= ASSIGN LEFT_SQUARE BOOLEAN_VALUE+ RIGHT_SQUARE
integerListAssign  ::= ASSIGN LEFT_SQUARE integerValue+ RIGHT_SQUARE
doubleListAssign   ::= ASSIGN LEFT_SQUARE (integerValue | DOUBLE_VALUE)+ RIGHT_SQUARE
naturalListAssign  ::= ASSIGN LEFT_SQUARE NATURAL_VALUE+ RIGHT_SQUARE

from::= FROM_KEY fromAnnotations? fromBody

fromBody::= NEW_LINE_INDENT (fromComponent NEWLINE+)+ DEDENT

fromComponent::= (doc? conceptSignature fromComponentAnnotations? conceptBody?) | (extendedConcept fromComponentAnnotations?)
{ mixin= 'monet.tara.compiler.intellij.psi.impl.TaraFromComponentMixin'
implements='monet.tara.compiler.intellij.psi.IConcept'
methods=[getIdentifier]
}
fromComponentAnnotations ::= OPEN_AN (HAS_CODE | EXTENSIBLE | SINGLETON)+ CLOSE_AN
conceptAnnotations     ::= OPEN_AN (ROOT | HAS_CODE | EXTENSIBLE | SINGLETON)+ CLOSE_AN
componentAnnotations   ::= OPEN_AN (MULTIPLE | OPTIONAL | HAS_CODE | EXTENSIBLE| SINGLETON)+ CLOSE_AN
fromAnnotations        ::= OPEN_AN (OPTIONAL | MULTIPLE)+ CLOSE_AN

integerValue::= NATURAL_VALUE
              | NEGATIVE_VALUE

modifier::= ABSTRACT
          | FINAL

doc::= DOC_LINE
     | DOC_BLOCK
