{
	parserClass='monet.tara.intellij.lang.parser.TaraParser'
	parserUtilClass="monet.tara.intellij.lang.parser.TaraParserUtil"
	psiVisitorName="TaraVisitor"
	extends='com.intellij.extapi.psi.ASTWrapperPsiElement'
	implements='monet.tara.intellij.lang.psi.TaraPsiElement'
	psiClassPrefix='Tara'
	psiImplClassSuffix='Impl'
	psiPackage='monet.tara.intellij.lang.psi'
	psiImplPackage='monet.tara.intellij.lang.psi.impl'

	elementTypeHolderClass='monet.tara.intellij.lang.psi.TaraTypes'
	elementTypeClass='monet.tara.intellij.lang.psi.TaraElementType'
	tokenTypeClass='monet.tara.intellij.lang.psi.TaraTokenType'

	psiImplUtilClass='monet.tara.intellij.lang.psi.impl.TaraPsiImplUtil'
}

root ::= NEWLINE* header? NEWLINE* concept?  NEWLINE*

header ::=  packet? importStatement*
packet ::= PACKAGE headerReference
importStatement ::= NEWLINE IMPORT_KEY headerReference {
	mixin= 'monet.tara.intellij.lang.psi.impl.ImportMixin'
	implements='monet.tara.intellij.lang.psi.Import'
}

doc::= DOC_LINE+ {
	mixin= 'monet.tara.intellij.lang.psi.impl.DocMixin'
	implements='monet.tara.intellij.lang.psi.Doc'
}

concept ::= doc? signature annotations? body? {
	mixin= 'monet.tara.intellij.lang.psi.impl.ConceptMixin'
	implements='monet.tara.intellij.lang.psi.Concept'
}

modifier::= ABSTRACT | FINAL | BASE_KEY
signature::= ((CASE_KEY identifier) | withHeritage | (metaIdentifier modifier? identifier)) parameters? {
	pin=1
	mixin= 'monet.tara.intellij.lang.psi.impl.SignatureMixin'
	implements='monet.tara.intellij.lang.psi.Signature'
}

private withHeritage ::= metaIdentifier COLON identifierReference modifier? identifier?{
	pin = 2
}

parameters ::= LEFT_PARENTHESIS parameterList? RIGHT_PARENTHESIS {
	pin=1
	mixin = 'monet.tara.intellij.lang.psi.impl.ParametersMixin'
	implements = 'monet.tara.intellij.lang.psi.Parameters'
}

private parameterList ::= explicit? parameter (COMMA explicit? parameter)*
{ pin=2}

explicit::= identifier COLON
{ pin=2}

parameter ::=     identifierReference
				| stringValue
		        | booleanValue
		        | naturalValue
		        | integerValue
		        | doubleValue
		        | stringList
		        | booleanList
		        | naturalList
		        | integerList
		        | doubleList
		        | identifierList
		        | empty
{mixin = 'monet.tara.intellij.lang.psi.impl.ParameterMixin'
implements = 'monet.tara.intellij.lang.psi.Parameter'}

empty::=

body ::= NEW_LINE_INDENT (conceptConstituents NEWLINE+)+ DEDENT {
	mixin= 'monet.tara.intellij.lang.psi.impl.BodyMixin'
	implements='monet.tara.intellij.lang.psi.Body'
}

private conceptConstituents ::= attribute | concept

attribute ::= doc? (aliasAttribute | naturalAttribute | integerAttribute | doubleAttribute | booleanAttribute | StringAttribute
                        | resource | referenceStatement | word) {
	pin=2
	mixin= 'monet.tara.intellij.lang.psi.impl.AttributeMixin'
	implements='monet.tara.intellij.lang.psi.Attribute'
}

private aliasAttribute   ::= (VAR | PROPERTY) ALIAS_TYPE IDENTIFIER_KEY (COLON stringValue)? {pin=2}
private booleanAttribute ::= (VAR | PROPERTY) BOOLEAN_TYPE ((IDENTIFIER_KEY (COLON booleanValue)?) | (LIST IDENTIFIER_KEY (COLON booleanList)?)) {pin=2}
private StringAttribute  ::= (VAR | PROPERTY) STRING_TYPE ((IDENTIFIER_KEY (COLON stringValue)?)   | (LIST IDENTIFIER_KEY (COLON stringList)?)) {pin=2}
private naturalAttribute ::= (VAR | PROPERTY) NATURAL_TYPE ((IDENTIFIER_KEY (COLON naturalValue)?) | (LIST IDENTIFIER_KEY (COLON naturalList)?)) {pin=2}
private integerAttribute ::= (VAR | PROPERTY) INT_TYPE ((IDENTIFIER_KEY (COLON integerValue)?)     | (LIST IDENTIFIER_KEY (COLON integerList)?)) {pin=2}
private doubleAttribute  ::= (VAR | PROPERTY) DOUBLE_TYPE ((IDENTIFIER_KEY (COLON doubleValue)?)   | (LIST IDENTIFIER_KEY (COLON doubleList)?)) {pin=2}
private resource         ::= (VAR | PROPERTY) RESOURCE_KEY COLON IDENTIFIER_KEY IDENTIFIER_KEY {pin=2}

stringValue  ::= STRING_VALUE_KEY
booleanValue ::= BOOLEAN_VALUE_KEY
naturalValue ::= NATURAL_VALUE_KEY
integerValue ::= NATURAL_VALUE_KEY | NEGATIVE_VALUE_KEY
doubleValue  ::= NATURAL_VALUE_KEY | NEGATIVE_VALUE_KEY | DOUBLE_VALUE_KEY

stringList  ::= LEFT_SQUARE STRING_VALUE_KEY+ RIGHT_SQUARE
booleanList ::= LEFT_SQUARE BOOLEAN_VALUE_KEY+ RIGHT_SQUARE
naturalList ::= LEFT_SQUARE NATURAL_VALUE_KEY+ RIGHT_SQUARE
integerList ::= LEFT_SQUARE (NATURAL_VALUE_KEY | NEGATIVE_VALUE_KEY)+ RIGHT_SQUARE
doubleList  ::= LEFT_SQUARE (NATURAL_VALUE_KEY | NEGATIVE_VALUE_KEY | DOUBLE_VALUE_KEY)+ RIGHT_SQUARE
identifierList ::= LEFT_SQUARE identifier+ RIGHT_SQUARE;

referenceStatement ::= doc? VAR identifierReference LIST? IDENTIFIER_KEY {
	mixin= 'monet.tara.intellij.lang.psi.impl.ReferenceStatementMixin'
	implements='monet.tara.intellij.lang.psi.ReferenceStatement'
}

word ::= doc? VAR WORD_KEY IDENTIFIER_KEY NEW_LINE_INDENT (IDENTIFIER_KEY NEWLINE)+ DEDENT {
	mixin= 'monet.tara.intellij.lang.psi.impl.WordMixin'
	implements='monet.tara.intellij.lang.psi.Word'
}

annotations ::= OPEN_AN (GENERIC | MULTIPLE | REQUIRED | HAS_NAME | intention | SINGLETON | ROOT)+ CLOSE_AN {
	pin=1
	mixin= 'monet.tara.intellij.lang.psi.impl.AnnotationsMixin'
	implements='monet.tara.intellij.lang.psi.Annotations'
}

intention ::= INTENTION_KEY {
	pin=1
	mixin= 'monet.tara.intellij.lang.psi.impl.ExternalReferenceMixin'
	implements='monet.tara.intellij.lang.psi.ExternalReference'
}

headerReference ::= hierarchy* identifier {
	pin=2
	mixin= 'monet.tara.intellij.lang.psi.impl.IdentifierReferenceMixin'
	implements='monet.tara.intellij.lang.psi.HeaderReference'
}

identifierReference::= hierarchy* identifier {
	pin=2
	mixin= 'monet.tara.intellij.lang.psi.impl.IdentifierReferenceMixin'
	implements='monet.tara.intellij.lang.psi.IdentifierReference'
}

private hierarchy ::= identifier DOT

identifier::=  IDENTIFIER_KEY {
	mixin= 'monet.tara.intellij.lang.psi.impl.IdentifierMixin'
	implements='monet.tara.intellij.lang.psi.Identifier'
}

metaIdentifier ::= METAIDENTIFIER_KEY {
	mixin= 'monet.tara.intellij.lang.psi.impl.MetaIdentifierMixin'
	implements='monet.tara.intellij.lang.psi.MetaIdentifier'
}