{
  parserClass='monet.tara.intellij.lang.parser.TaraParser'
  parserUtilClass="monet.tara.intellij.lang.parser.TaraParserUtil"

  extends='com.intellij.extapi.psi.ASTWrapperPsiElement'

  psiClassPrefix='Tara'
  psiImplClassSuffix='Impl'
  psiPackage='monet.tara.intellij.lang.psi'
  psiImplPackage='monet.tara.intellij.lang.psi.impl'

  elementTypeHolderClass='monet.tara.intellij.lang.psi.TaraTypes'
  elementTypeClass='monet.tara.intellij.lang.psi.TaraElementType'
  tokenTypeClass='monet.tara.intellij.lang.psi.TaraTokenType'

  psiImplUtilClass='monet.tara.intellij.lang.psi.impl.TaraPsiImplUtil'
}

root ::= (concept | NEWLINE)*

concept ::= doc? signature annotations? body?
{ mixin= 'monet.tara.intellij.lang.psi.impl.ConceptMixin'
implements='monet.tara.intellij.lang.psi.Concept'
}

signature ::= CONCEPT_KEY referenceIdentifier?  (polymorphic | modifier? morph?)  AS identifier
{ mixin= 'monet.tara.intellij.lang.psi.impl.SignatureMixin'
implements='monet.tara.intellij.lang.psi.Signature'
}

body ::= NEW_LINE_INDENT (conceptConstituents NEWLINE+)+ DEDENT
{ mixin= 'monet.tara.intellij.lang.psi.impl.BodyMixin'
implements='monet.tara.intellij.lang.psi.Body'
}

private conceptConstituents ::= attribute
		                      | referenceStatement
		                      | word
		                      | concept
		                      | conceptInjection

referenceStatement::= VAR referenceIdentifier LIST? variableNames
{mixin= 'monet.tara.intellij.lang.psi.impl.ReferenceStatementMixin'
implements='monet.tara.intellij.lang.psi.ReferenceStatement'}
conceptInjection::= NEW referenceIdentifier annotations?
{mixin= 'monet.tara.intellij.lang.psi.impl.ConceptInjectionMixin'
implements='monet.tara.intellij.lang.psi.ConceptInjection'}

attribute::= VAR     UID_TYPE IDENTIFIER_KEY (ASSIGN stringValue)?
           | VAR     INT_TYPE (variableNames | IDENTIFIER_KEY ASSIGN integerValue | LIST IDENTIFIER_KEY (ASSIGN integerList)?)
           | VAR  DOUBLE_TYPE (variableNames | IDENTIFIER_KEY ASSIGN doubleValue | LIST IDENTIFIER_KEY (ASSIGN doubleList)?)
           | VAR NATURAL_TYPE (variableNames | IDENTIFIER_KEY ASSIGN naturalValue | LIST IDENTIFIER_KEY (ASSIGN naturalList)?)
           | VAR BOOLEAN_TYPE (variableNames | IDENTIFIER_KEY ASSIGN booleanValue | LIST IDENTIFIER_KEY (ASSIGN booleanList)?)
           | VAR  STRING_TYPE (variableNames | IDENTIFIER_KEY ASSIGN stringValue | LIST IDENTIFIER_KEY (ASSIGN stringList)?)
{mixin= 'monet.tara.intellij.lang.psi.impl.AttributeMixin'
implements='monet.tara.intellij.lang.psi.Attribute'}

word::= VAR WORD_KEY IDENTIFIER_KEY NEW_LINE_INDENT (IDENTIFIER_KEY NEWLINE)+ DEDENT
{ mixin= 'monet.tara.intellij.lang.psi.impl.WordMixin'
implements='monet.tara.intellij.lang.psi.NodeWord'
}

stringValue  ::= STRING_VALUE_KEY
booleanValue ::= BOOLEAN_VALUE_KEY
integerValue ::= NATURAL_VALUE_KEY | NEGATIVE_VALUE_KEY
doubleValue  ::= NATURAL_VALUE_KEY | NEGATIVE_VALUE_KEY | DOUBLE_VALUE_KEY
naturalValue ::= NATURAL_VALUE_KEY

stringList ::= LEFT_SQUARE STRING_VALUE_KEY+ RIGHT_SQUARE;
booleanList::= LEFT_SQUARE BOOLEAN_VALUE_KEY+ RIGHT_SQUARE;
integerList::= LEFT_SQUARE (NATURAL_VALUE_KEY | NEGATIVE_VALUE_KEY)+ RIGHT_SQUARE;
doubleList ::= LEFT_SQUARE (NATURAL_VALUE_KEY | NEGATIVE_VALUE_KEY | DOUBLE_VALUE_KEY)+ RIGHT_SQUARE;
naturalList::= LEFT_SQUARE NATURAL_VALUE_KEY+ RIGHT_SQUARE;

annotations ::= OPEN_AN (MULTIPLE | OPTIONAL | HAS_CODE | EXTENSIBLE| SINGLETON | ROOT)+ CLOSE_AN
{mixin= 'monet.tara.intellij.lang.psi.impl.AnnotationsMixin'
implements='monet.tara.intellij.lang.psi.Annotations'}

variableNames::= IDENTIFIER_KEY (COMMA IDENTIFIER_KEY)*;

modifier::= ABSTRACT
          | FINAL

polymorphic::= POLYMORPHIC_KEY
morph::= MORPH_KEY

doc::= DOC_LINE+

referenceIdentifier::= identifier (DOT identifier)*
{mixin= 'monet.tara.intellij.lang.psi.impl.IdentifierReferenceMixin'
implements='monet.tara.intellij.lang.psi.IdentifierReference'}

identifier::=  IDENTIFIER_KEY
{mixin= 'monet.tara.intellij.lang.psi.impl.IdentifierMixin'
implements='monet.tara.intellij.lang.psi.Identifier'}