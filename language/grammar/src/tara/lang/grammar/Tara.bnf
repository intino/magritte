{
	parserClass='tara.intellij.lang.parser.TaraParser'
	parserUtilClass="tara.intellij.lang.parser.TaraParserUtil"
	psiVisitorName="TaraVisitor"
	extends='com.intellij.extapi.psi.ASTWrapperPsiElement'
	implements='tara.intellij.lang.psi.TaraPsiElement'
	psiClassPrefix='Tara'
	psiImplClassSuffix='Impl'
	psiPackage='tara.intellij.lang.psi'
	psiImplPackage='tara.intellij.lang.psi.impl'

	elementTypeHolderClass='tara.intellij.lang.psi.TaraTypes'
	elementTypeClass='tara.intellij.lang.psi.TaraElementType'
	tokenTypeClass='tara.intellij.lang.psi.TaraTokenType'

	psiImplUtilClass='tara.intellij.lang.psi.impl.TaraPsiImplUtil'
}

root ::=COMMENT? NEWLINE* (dslDeclaration NEWLINE+)? imports? (node NEWLINE+)*

dslDeclaration ::= DSL headerReference

imports ::= (anImport NEWLINE*)+

anImport ::= USE headerReference NEWLINE {
	mixin= 'tara.intellij.lang.psi.impl.ImportMixin'
    implements='tara.intellij.lang.psi.Import'
}

doc ::= (DOC_LINE NEWLINE?)+ {
	mixin= 'tara.intellij.lang.psi.impl.DocMixin'
	implements='tara.intellij.lang.psi.Doc'
}

node ::= doc? signature body? {
	pin = 2
	mixin= 'tara.intellij.lang.psi.impl.NodeMixin'
	implements='tara.intellij.lang.psi.TaraPsiElement, tara.lang.model.Node, com.intellij.openapi.util.Iconable, com.intellij.pom.Navigatable'
}

signature::= (subNode | (metaIdentifier ruleContainer? parameters? (identifier ruleContainer?)? parent?)) (withTable | facetTarget? tags? anchor?)  {
	pin = 1
	mixin= 'tara.intellij.lang.psi.impl.SignatureMixin'
	implements='tara.intellij.lang.psi.Signature'
}
withTable ::= LIST WITH identifierReference tableParameters {
	pin = 1
}
tableParameters ::=LEFT_PARENTHESIS (IDENTIFIER_KEY+ (COMMA IDENTIFIER_KEY+)*)? RIGHT_PARENTHESIS

private subNode ::= SUB ruleContainer? parameters? identifier ruleContainer?
{pin = 1}

private parent ::= EXTENDS identifierReference
{pin = 1}

parameters ::= LEFT_PARENTHESIS (parameter (COMMA parameter)*)? RIGHT_PARENTHESIS {
	pin = 1
	mixin = 'tara.intellij.lang.psi.impl.ParametersMixin'
	implements = 'tara.intellij.lang.psi.Parameters'
}

parameter ::= (identifier EQUALS)? value {
    pin = 2
	mixin = 'tara.intellij.lang.psi.impl.ParameterMixin'
	implements = 'tara.intellij.lang.psi.Valued, tara.lang.model.Parameter, com.intellij.pom.Navigatable'
}

anchor ::= ANCHOR_VALUE

body ::= (NEW_LINE_INDENT NEWLINE? | INLINE) (nodeConstituents NEWLINE+)+ DEDENT {
	pin = 1
	mixin = 'tara.intellij.lang.psi.impl.BodyMixin'
	implements = 'tara.intellij.lang.psi.Body'
}

private nodeConstituents ::= varInit | variable | node | facetApply | nodeReference

nodeReference ::= HAS ruleContainer? identifierReference ruleContainer? tags? {
	pin = 1
	mixin = 'tara.intellij.lang.psi.impl.NodeReferenceMixin'
	implements = 'tara.intellij.lang.psi.TaraPsiElement, tara.lang.model.Node, com.intellij.pom.Navigatable'
}

variable ::= doc? VAR variableType sizeRange? ruleContainer? identifier (EQUALS value)? flags? anchor? bodyValue? {
	pin = 2
	mixin = 'tara.intellij.lang.psi.impl.VariableMixin'
	implements = 'tara.intellij.lang.psi.TaraPsiElement, tara.lang.model.Variable, tara.intellij.lang.psi.Valued, com.intellij.openapi.util.Iconable, com.intellij.pom.Navigatable, com.intellij.psi.PsiNamedElement'
}
bodyValue ::= NEW_LINE_INDENT (stringValue | expression) NEWLINE? DEDENT
{
	mixin = 'tara.intellij.lang.psi.impl.ValueMixin'
    implements = 'tara.intellij.lang.psi.TaraPsiElement, tara.intellij.lang.psi.Value'
}

variableType::= FUNCTION_TYPE
                | INT_TYPE
                | DOUBLE_TYPE
                | BOOLEAN_TYPE
                | STRING_TYPE
                | DATE_TYPE
                | TIME_TYPE
                | WORD_TYPE
                | OBJECT_TYPE
                | RESOURCE_TYPE
                | identifierReference

sizeRange ::= LEFT_SQUARE size? RIGHT_SQUARE
size ::= NATURAL_VALUE_KEY | listRange

listRange ::= (NATURAL_VALUE_KEY | STAR) DOT DOT (NATURAL_VALUE_KEY | STAR)

ruleContainer ::= COLON rule
{pin=1}

rule ::= (LEFT_CURLY (classTypeValue | identifier+ | ((range | stringValue) metric?) | metric) RIGHT_CURLY) | identifierReference {
	mixin = 'tara.intellij.lang.psi.impl.RuleMixin'
	implements = 'tara.intellij.lang.psi.Rule, tara.intellij.lang.psi.TaraPsiElement'
}

range ::= (doubleValue | integerValue | STAR) DOT DOT (doubleValue | integerValue | STAR)

classTypeValue ::= CLASS_TYPE

value ::= stringValue+
        | booleanValue+
        | tupleValue+
        | integerValue+ metric?
        | doubleValue+  metric?
        | expression+
        | emptyField
        | identifierReference+
        | methodReference+
{
	mixin = 'tara.intellij.lang.psi.impl.ValueMixin'
    implements = 'tara.intellij.lang.psi.Value, tara.intellij.lang.psi.TaraPsiElement'
}

methodReference ::= AT identifierReference
{pin = 1}

stringValue ::= (QUOTE_BEGIN CHARACTER* QUOTE_END) {
	mixin = 'tara.intellij.lang.psi.impl.StringMixin'
    implements = 'tara.intellij.lang.psi.StringValue, tara.intellij.lang.psi.TaraPsiElement'
}

expression  ::= (EXPRESSION_BEGIN CHARACTER* EXPRESSION_END) {
	mixin = 'tara.intellij.lang.psi.impl.ExpressionMixin'
    implements = 'tara.intellij.lang.psi.Expression, tara.intellij.lang.psi.TaraPsiElement'
}

booleanValue    ::= BOOLEAN_VALUE_KEY
tupleValue      ::= stringValue COLON doubleValue
integerValue    ::= NATURAL_VALUE_KEY | NEGATIVE_VALUE_KEY
doubleValue     ::= NATURAL_VALUE_KEY | NEGATIVE_VALUE_KEY | DOUBLE_VALUE_KEY
metric          ::= identifier | METRIC_VALUE_KEY

facetApply ::= AS metaIdentifier parameters? (WITH metaIdentifier)? body? {
	pin = 1
	mixin = 'tara.intellij.lang.psi.impl.FacetApplyMixin'
    implements = 'tara.intellij.lang.psi.TaraPsiElement, tara.lang.model.Facet, com.intellij.pom.Navigatable'
}

facetTarget ::= ON (identifierReference | ANY) constraint? {
	pin = 1
	mixin = 'tara.intellij.lang.psi.impl.FacetTargetMixin'
	implements = 'tara.intellij.lang.psi.TaraPsiElement, tara.lang.model.FacetTarget, com.intellij.pom.Navigatable'
}
constraint::= WITH identifierReference (COMMA identifierReference)*
{pin = 1}

tags ::= flags? annotations? {
	pin = 1
	mixin = 'tara.intellij.lang.psi.impl.TagsMixin'
	implements = 'tara.intellij.lang.psi.Tags'
}

flags::= IS flag+ {
	pin = 1
	mixin = 'tara.intellij.lang.psi.impl.FlagsMixin'
	implements = 'tara.intellij.lang.psi.Flags'
}

flag ::= ABSTRACT | TERMINAL | PRIVATE | REACTIVE | COMPONENT
	| FEATURE | ENCLOSED | FINAL | CONCEPT | VOLATILE | VERSIONED {
	mixin = 'tara.intellij.lang.psi.impl.FlagMixin'
	implements = 'tara.intellij.lang.psi.Flag'
}

annotations ::= INTO annotation+ {
	pin = 1
	mixin = 'tara.intellij.lang.psi.impl.AnnotationsMixin'
	implements = 'tara.intellij.lang.psi.Annotations'
}

annotation ::= COMPONENT | FEATURE | ENCLOSED {
	mixin = 'tara.intellij.lang.psi.impl.AnnotationMixin'
	implements = 'tara.intellij.lang.psi.Annotation'
}

varInit ::= identifier ((EQUALS value) | bodyValue) {
    pin = 2
	mixin = 'tara.intellij.lang.psi.impl.VarInitMixin'
	implements = 'tara.intellij.lang.psi.Valued, tara.lang.model.Parameter'
}

emptyField ::= EMPTY_REF

headerReference ::= hierarchy* identifier {
	pin = 2
	mixin = 'tara.intellij.lang.psi.impl.IdentifierReferenceMixin'
	implements = 'tara.intellij.lang.psi.HeaderReference'
}

identifierReference ::= hierarchy* identifier {
	pin = 2
	mixin = 'tara.intellij.lang.psi.impl.IdentifierReferenceMixin'
	implements = 'tara.intellij.lang.psi.IdentifierReference'
}

private hierarchy ::= identifier (DOT | PLUS)
{pin = 2}

identifier ::=  IDENTIFIER_KEY {
	mixin = 'tara.intellij.lang.psi.impl.IdentifierMixin'
	implements = 'tara.intellij.lang.psi.Identifier'
}

metaIdentifier ::= METAIDENTIFIER_KEY | IDENTIFIER_KEY {
	mixin = 'tara.intellij.lang.psi.impl.MetaIdentifierMixin'
	implements = 'tara.intellij.lang.psi.MetaIdentifier'
}